(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.webit || (g.webit = {})).calendar = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var cloneDate = require('./cloneDate');

/**
 * Atgriežam jaunu datuma objektu, kuram pielikts norādītais skaits dienu
 * @param object Datums
 * @param number Dienu skaits ko pielikts. Ja neg, tad atņemt
 */
function addDays(date, daysCount) {
    var d = cloneDate(date);

    d.setDate(d.getDate()+daysCount);

    return d;
}

module.exports = addDays;
},{"./cloneDate":4}],2:[function(require,module,exports){
var cloneDate = require('./cloneDate');
var daysInMonth = require('./daysInMonth');

function addMonths(date, monthsCount) {
    var d = cloneDate(date);

    // Nolasām current date
    var n = d.getDate();

    // Uzliekam mēneša pirmo dienu. Lai nebūtu problēmu ar februāra mēnesi
    d.setDate(1);
    d.setMonth(d.getMonth() + monthsCount);

    // Mēģinām uzstādīt atpakaļ iepriekšējo datumu
    // Ja iepriekšējais datums ir lielāks nekā esošajā mēnesī,
    // tad uzstādām pēdējo iespējamo lielāko
    d.setDate(Math.min(n, daysInMonth(d.getFullYear(), d.getMonth()+1)));
    
    return d;
}

module.exports = addMonths;
},{"./cloneDate":4,"./daysInMonth":6}],3:[function(require,module,exports){
var domRender = require('./dom/render');

module.exports = {
    dom: domRender
}
},{"./dom/render":12}],4:[function(require,module,exports){
function cloneDate(date) {
    return new Date(date.getTime());
}

module.exports = cloneDate
},{}],5:[function(require,module,exports){
/**
 * Nedēļas diena ir not zero based
 * Pirmdiena ir 1
 * Svētdiena ir 7
 */
function dayOfWeek(date) {
    if (typeof date == 'undefined') {
        date = new Date();
    }

    var r = date.getDay();
    // Svētdiena
    if (r == 0) {
        r = 7;
    }

    return r;
}

module.exports = dayOfWeek;
},{}],6:[function(require,module,exports){
function daysInMonth(year, month) {
    return new Date(year, month, 0).getDate();
}

module.exports = daysInMonth;
},{}],7:[function(require,module,exports){
function navPrev(props) {
    var el = document.createElement('a');
    el.className = 'calendar__nav calendar__nav--prev';

    var c = props.get('navPrevFormatter', defaultNavPrevFormatter)()

    /**
     * Ja formatter atgriež string, tad veidojam document.createTextNode
     * pretējā gadījumā vienkārši appendChild
     */
    el.appendChild(
        typeof c == 'string' ? document.createTextNode(c) : c
    );

    return el;
}

function navNext(props) {
    var el = document.createElement('a');
    el.className = 'calendar__nav calendar__nav--next';

    var c = props.get('navNextFormatter', defaultNavNextFormatter)()

    /**
     * Ja formatter atgriež string, tad veidojam document.createTextNode
     * pretējā gadījumā vienkārši appendChild
     */
    el.appendChild(
        typeof c == 'string' ? document.createTextNode(c) : c
    );

    return el;
}

function dateCaption(date, captionTextNode) {
    var el = document.createElement('a');
    el.className = 'calendar__datecaption';

    el.appendChild(captionTextNode);

    return el;
}

function dateCaptionTextNode(date, props) {
    return document.createTextNode(props.get('fullDateFormatter', defaultFullDateFormatter)(date))
}

function defaultFullDateFormatter(date) {
    return date.getFullYear()+'-'+(date.getMonth()+1)+'-'+date.getDate()
}

function defaultNavPrevFormatter() {
    return '<';
}

function defaultNavNextFormatter() {
    return '>';
}

function dateSwitchDomElement(date, props) {
    
    this.props = props;

    this.el = document.createElement('div');
    
    this.navPrev = navPrev(this.props);
    this.navNext = navNext(this.props);
    this.dateCaptionTextNode = dateCaptionTextNode(date, this.props)
    this.dateCaption = dateCaption(date, this.dateCaptionTextNode);
    
    this.el.className = 'calendar__switch';

    this.el.appendChild(this.navPrev);
    this.el.appendChild(this.dateCaption);
    this.el.appendChild(this.navNext);
}

dateSwitchDomElement.prototype = {
    getEl: function() {
        return this.el;
    },
    
    getNavPrev: function() {
        return this.navPrev;
    },
    getNavNext: function() {
        return this.navNext;
    },
    getDateCaption: function() {
        return this.dateCaption
    },

    isNavPrev: function(el) {
        return this.navPrev == el;
    },
    isNavNext: function(el) {
        return this.navNext == el;
    },
    isDateCaption: function(el) {
        return this.dateCaption == el;
    },

    setDate: function(date) {
        this.dateCaptionTextNode.nodeValue = this.props.get('fullDateFormatter', defaultFullDateFormatter)(date)
    }
}

module.exports = dateSwitchDomElement;
},{}],8:[function(require,module,exports){
var emptyElement = require('./emptyElement');

function addCssClasses(el, date) {

    var c = ['calendar__date'];

    if (date.dateProps.currMonth) {
        c.push('calendar__date--currentmonth');
    }
    else if (date.dateProps.prevMonth) {
        c.push('calendar__date--prevmonth');
    }
    else if (date.dateProps.nextMonth) {
        c.push('calendar__date--nextmonth');
    }

    if (date.dateProps.currDate) {
        c.push('calendar__date--currdate');
    }

    // Weekday
    c.push('calendar__date--wd-'+date.dateProps.weekDay)

    el.className = c.join(' ');

    return el;
}

/**
 * Noklusētais datuma formatētājs
 */
function defaultMonthDayFormatter(date, currentEl) {
    if (currentEl) {
        currentEl.nodeValue = date.date.getDate()
    }
    else {
        currentEl = document.createTextNode(date.date.getDate());
    }

    return currentEl;
}

function createDomDayElement(date, props) {
    this.props = props;

    this.el = addCssClasses(document.createElement('div'), date);
    
    this.elContent = this.props.get('monthDayFormatter', defaultMonthDayFormatter)(date, null);
    
    this.el.appendChild(this.elContent);
}

createDomDayElement.prototype = {
    getEl: function() {
        return this.el;
    },
    setDate: function(date) {
        addCssClasses(this.el, date);

        var newElContent = this.props.get('monthDayFormatter', defaultMonthDayFormatter)(date, this.elContent)

        // Ja atgriezts cits elContent
        if (!this.el.contains(newElContent)) {
            this.elContent = newElContent;

            emptyElement(this.el).appendChild(this.elContent)
        }
    }
}

module.exports = createDomDayElement;
},{"./emptyElement":9}],9:[function(require,module,exports){
function emptyElement(el) {
    while(el.firstChild) {
        el.removeChild(el.firstChild);
    }

    return el;
}

module.exports = emptyElement;
},{}],10:[function(require,module,exports){
var getMonthStructure = require('../monthStructure');
var setMonthStructureDatesProps = require('../setMonthStructureDatesProps');
var each2d = require('../each2d');
var find2d = require('../find2d');
var cloneDate = require('../cloneDate');
var daysInMonth = require('../daysInMonth');

var dayEl = require('./dayEl');

function monthEl(date, props) {
    this.el = document.createElement('div');
    this.el.className = 'calendar__month';

    this.date = cloneDate(date);

    this.days = [];

    var weekEl, monthStructure = setMonthStructureDatesProps(getMonthStructure(this.date), this.date);
    for (var w = 0; w < monthStructure.length; w++) {

        weekEl = document.createElement('div');
        weekEl.className = 'calendar__week';

        for (var d = 0; d < monthStructure[w].length; d++) {

            if (typeof this.days[w] == 'undefined') {
                this.days[w] = [];
            }

            this.days[w][d] = {
                data: monthStructure[w][d],
                el: new dayEl(monthStructure[w][d], props)
            }

            // Uzstādām dažādas css klases, kas raksturo datumu
            weekEl.appendChild(this.days[w][d].el.getEl());
        }

        this.el.appendChild(weekEl);
    }
}

monthEl.prototype = {
    getEl: function() {
        return this.el;
    },
    getDays: function() {
        return this.days
    },
    getDate: function() {
        return this.date;
    },
    findDayByEl: function(el) {
        return find2d(this.days, function(item){
            return item.el.getEl().contains(el)
        }, function(foundItem){
            return foundItem.data;
        })
    },
    applyDateChanges: function(date) {
        var mthis = this;
        each2d(setMonthStructureDatesProps(getMonthStructure(date), date), function(item, w, d){
            mthis.days[w][d].data = item;
            mthis.days[w][d].el.setDate(item)
        })
    },
    setDate: function(date) {
        this.date = cloneDate(date);

        this.applyDateChanges(this.date);
    },
    /**
     * Nomainām tikai datuma (dd) daļu esošajā datumā
     */
    changeMonthDate: function(date) {
        // Ja datuma daļa neatšķiras, tad neturpinām
        if (this.date.getDate() == date) {
            return;
        }

        this.date.setDate(Math.min(date, daysInMonth(this.date.getFullYear(), this.date.getMonth()+1)))

        this.applyDateChanges(this.date);
    }
}

module.exports = monthEl;
},{"../cloneDate":4,"../daysInMonth":6,"../each2d":17,"../find2d":19,"../monthStructure":25,"../setMonthStructureDatesProps":27,"./dayEl":8}],11:[function(require,module,exports){
var each = require('../each');
var find = require('../find');

function months() {
    this.months = []
}

months.prototype = {
    push: function(month) {
        this.months.push(month);
        
        return month;
    },
    each: function(cb) {
        each(this.months, cb)
    },
    findDayByEl: function(el) {
        var r = false;
        for (var i = 0; i < this.months.length; i++) {
            r = this.months[i].findDayByEl(el);
            if (r) {
                break;
            }
        }
        return r;
    },
    /**
     * Atrodam to mēnesi, kura elements atrodas 
     * padotajā container elementā
     */
    findMonthByConainer: function(containerEl) {
        return find(this.months, function(item){
            return containerEl.contains(item.el)
        })
    },

    findByYearMonth: function(year, month) {
        return find(this.months, function(item){
            return item.getDate().getFullYear() == year && (item.getDate().getMonth()+1) == month
        })
    }
}

module.exports = months
},{"../each":16,"../find":18}],12:[function(require,module,exports){
var domEvents = require('../domEvents');
var addMonths = require('../addMonths');
var cloneDate = require('../cloneDate');
var properties = require('../properties');
var isLowerMonthThan = require('../isLowerMonthThan');
var isHigherMonthThan = require('../isHigherMonthThan');
var isSameMonth = require('../isSameMonth');

var dateSwitchEl = require('./dateSwitchEl');
var weekDaysEl = require('./weekDaysEl');
var monthEl = require('./monthEl');
var months = require('./months');

var emptyElement = require('./emptyElement');

var infinityswipe = require('infinityswipe');


function render(date, props) {
    var mthis = this;

    this.events = this.prepareEvents([
        'dateclick', 'prevclick', 'nextclick', 'datecaptionclick'
    ]);

    this.props = new properties(props);

    this.date = cloneDate(date);

    this.el = document.createElement('div');
    this.el.className = 'calendar';

    
    this.dateSwitch = new dateSwitchEl(this.date, this.props);
    this.el.appendChild(this.dateSwitch.getEl());

    this.weekDays = new weekDaysEl(this.props);
    this.el.appendChild(this.weekDays.getEl());


    this.slidesEl = document.createElement('div');
    this.slidesEl.className = 'calendar__slides';
    this.el.appendChild(this.slidesEl);

    // Slide elements
    this.slideEls = [];

    for (var si = 0; si < 10; si++) {
        var sel = document.createElement('div');
        sel.className = 'calendar__slide';
        this.slidesEl.appendChild(sel);
        this.slideEls.push(sel);
    }
    

    // Mēnešu elementu kolekcija
    this.months = new months();

    this.initInfinitySwipe();

    this.setEvents('add');
}

render.prototype = {
    setEvents: function(mode) {

        var mthis = this;
        function click(ev) {

            var t = domEvents.eventTarget(ev);
            
            var day = mthis.months.findDayByEl(t);
            if (day) {
                mthis.handleMonthDayClick(day)
            }
            else if (mthis.dateSwitch.isNavPrev(t)) {

                mthis.infty.prevSlide();

                mthis.fire('prevclick', []);
            }
            else if (mthis.dateSwitch.isNavNext(t)) {

                mthis.infty.nextSlide();

                mthis.fire('nextclick', []);
            }
            else if (mthis.dateSwitch.isDateCaption(t)) {
                mthis.fire('datecaptionclick', []);
            }
        }

        /**
         * @todo Pārtaisīt uz external funkciju, pretējā gadījumā nevar novākt listener
         */
        if (mode == 'add') {
            domEvents.addEvent(this.el, 'click', click)
        }
        else {
            domEvents.removeEvent(this.el, 'click', click);
        }

        this.infty.onChange(function(){
            mthis.handleSlideChange();
        })

        this.infty.onSlideAdd(function(index, el){
            mthis.handleSlideAdd(index, el)
        });
    },

    prepareEvents: function(eventNames) {
        var r = {};
        for ( var i in eventNames ) {
            r[eventNames[i]] = [];
        }
        return r;
    },

    on: function(eventName, cb) {
        if (typeof this.events[eventName] != 'undefined') {
            this.events[eventName].push(cb);
        }

        return this;
    },

    /**
     * Fire events attached callbacks
     */
    fire: function(eventName, args) {
        for (var i in this.events[eventName]) {
            this.events[eventName][i].apply(this, args);
        }
    },

    getEl: function() {
        return this.el;
    },

    /**
     * Uzstādām jaunu datumu
     */
    setDate: function(date) {
        var mthis = this;
        
        this.date = cloneDate(date);
        this.dateSwitch.setDate(date);

        // Jānomaina datums (tikai date daļa) visos kalendāros
        this.months.each(function(month){
            month.changeMonthDate(mthis.date.getDate())
        })
    },

    getMonthByYearMonth: function(year, month) {
        return this.months.findByYearMonth(year, month);
    },

    handleMonthDayClick: function(day) {
        var mthis = this;

        // Pārbaudām vai vajag pārslēgties uz prev/next mēnesi
        if (!isSameMonth(this.date, day.date)) {
            if (isLowerMonthThan(day.date, this.date)) {
                setTimeout(function(){
                    mthis.infty.prevSlide();
                }, 2)
            }
            else if (isHigherMonthThan(day.date, this.date)) {
                setTimeout(function(){
                    mthis.infty.nextSlide();
                }, 2)
            }
        }

        this.setDate(day.date);

        this.fire('dateclick', [day.date]);
    },

    handleSlideAdd: function(index, el) {
        // Pārbaudām vai slide elementā jau ir mēneša elements
        var month = this.months.findMonthByConainer(el);

        if (!month) {
            month = this.months.push(new monthEl(addMonths(this.inftySlidesDate, index), this.props));
        }
        else {
            month.setDate(addMonths(this.inftySlidesDate, index))
        }

        emptyElement(el).appendChild(month.el);
    },

    handleSlideChange: function() {
        var current = this.infty.getCurrent();
        var month = this.months.findMonthByConainer(current.el);

        this.setDate(month.getDate())
    },

    initInfinitySwipe: function() {
        /**
         * Šis datums tiks izmantots, lai uzstādītu slaidos datumu
         * Slaidiem ir offset no pirmā slide. Šim datuma tiks likts klāt
         * slaida offset kā mēnesis un tādā veidā zināšu 
         * kādu mēnesi renderēt attiecīgajā slaidā. 
         * Šim datumam nekad nevajadzētu mainīties gadam un mēnesim.
         * Datuma daļa (dd) var mainīties atkarībā no izvēlētā
         */
        this.inftySlidesDate = cloneDate(this.date);
        this.infty = new infinityswipe(this.slidesEl, this.slideEls, {
            positionItems: true
        })
    },

    destroy: function() {
        this.setEvents('remove');

        if (this.el) {
            this.el.parentNode.removeChild(this.el);
            delete this.el;
        }
    }
}

module.exports = render;
},{"../addMonths":2,"../cloneDate":4,"../domEvents":15,"../isHigherMonthThan":21,"../isLowerMonthThan":22,"../isSameMonth":24,"../properties":26,"./dateSwitchEl":7,"./emptyElement":9,"./monthEl":10,"./months":11,"./weekDaysEl":14,"infinityswipe":32}],13:[function(require,module,exports){
var emptyElement = require('./emptyElement');

var abr = ['M', 'T', 'W', 'Th', 'F', 'S', 'Sn'];
var props;

function addCssClasses(el) {

    el.className = 'calendar__weekday';

    return el;
}

/**
 * Noklusētais datuma formatētājs
 */
function defaultWeekDayFormatter(day, currentEl) {
    if (currentEl) {
        currentEl.nodeValue = props.get('weekDayToText', defaultWeekDayToText)(day)
    }
    else {
        currentEl = document.createTextNode(props.get('weekDayToText', defaultWeekDayToText)(day));
    }

    return currentEl;
}

function createDomWeekDayElement(day, properties) {
    props = properties;

    this.el = addCssClasses(document.createElement('div'));
    
    this.elContent = props.get('weekDayFormatter', defaultWeekDayFormatter)(day, null);
    
    this.el.appendChild(this.elContent);
}

function defaultWeekDayToText(index) {
    return abr[index];
}

createDomWeekDayElement.prototype = {
    getEl: function() {
        return this.el;
    }
}

module.exports = createDomWeekDayElement;
},{"./emptyElement":9}],14:[function(require,module,exports){
var weekDayEl = require('./weekDayEl');

/**
 * Noklusētais formatētājs
 */
function defaultWeekDayFormatter(date, currentEl) {
    if (currentEl) {
        currentEl.nodeValue = date.date.getDate()
    }
    else {
        currentEl = document.createTextNode(date.date.getDate());
    }

    return currentEl;
}

function weekDaysDomElement(props) {
    
    this.props = props;

    this.el = document.createElement('div');
    this.el.className = 'calendar__weekdays';

    this.days = [];
    for (var i = 0; i < 7; i++) {
        this.days[i] = {
            el: new weekDayEl(i, this.props)
        }
        this.el.appendChild(this.days[i].el.getEl());
    }
}

weekDaysDomElement.prototype = {
    getEl: function() {
        return this.el;
    }
}

module.exports = weekDaysDomElement;
},{"./weekDayEl":13}],15:[function(require,module,exports){
function addEvent(obj, type, fn, params) {
    params = (typeof params == 'undefined' ? false : params);
    if ( obj.attachEvent ) {
        obj['e'+type+fn] = fn;
        obj[type+fn] = function(){obj['e'+type+fn](window.event)}
        obj.attachEvent('on'+type, obj[type+fn]);
    }
    else {
        obj.addEventListener(type, fn, params);
    }
}

function removeEvent(obj, type, fn, params) {
    params = (typeof params == 'undefined' ? false : params);
    if ( obj.detachEvent ) {
        obj.detachEvent( 'on'+type, obj[type+fn] );
        obj[type+fn] = null;
    }
    else {
        obj.removeEventListener(type, fn, params);
    }
}

function preventEvent(ev) {
    if (ev.preventDefault) {
        ev.preventDefault();
    }
    else {
        ev.returnValue = false;
    }
}

/**
 * Normalize event.target
 */
function eventTarget(ev) {
    var el;

    if (ev.target) {
        el = ev.target;
    }
    else if (ev.srcElement) {
        el = ev.srcElement
    }
    
    // Safari bug. Selected text returns text
    if (el.nodeType == 3) {
        el = el.parentNode
    }

    return el;
}

module.exports = {
    addEvent: addEvent,
    removeEvent: removeEvent,
    preventEvent: preventEvent,
    eventTarget: eventTarget
}
},{}],16:[function(require,module,exports){
function each(arr, cb) {
    for (var i = 0; i < arr.length; i++) {
        cb(arr[i], i);
    }
}

module.exports = each;
},{}],17:[function(require,module,exports){
/**
 * Apply callback for each item of 2 dimensional array
 */
function each2d(arr, cb) {
    for (var i = 0; i < arr.length; i++) {
        for (var j = 0; j < arr[i].length; j++) {
            cb(arr[i][j], i, j);
        }
    }
}

module.exports = each2d;
},{}],18:[function(require,module,exports){
function find(arr, cb, foundItemCb) {
    for (var i = 0; i < arr.length; i++) {
        if (cb(arr[i], i) === true) {
            if (foundItemCb) {
                return foundItemCb(arr[i]);
            }
            else {
                return arr[i];
            }
        }
    }

    return false;
}

module.exports = find;
},{}],19:[function(require,module,exports){
function find2d(arr, cb, foundItemCb) {
    for (var i = 0; i < arr.length; i++) {
        for (var j = 0; j < arr[i].length; j++) {
            if (cb(arr[i][j], i, j) === true) {
                if (foundItemCb) {
                    return foundItemCb(arr[i][j]);
                }
                else {
                    return arr[i][j];    
                }
            }
        }
    }

    return false;
}

module.exports = find2d;
},{}],20:[function(require,module,exports){
var isSameMonth = require('./isSameMonth');
var isSameDate = require('./isSameDate');
var isLowerMonthThan = require('./isLowerMonthThan');
var isHigherMonthThan = require('./isHigherMonthThan');
var dayOfWeek = require('./dayOfWeek');

function getDateProps(date, currentDate) {
    return {
        currMonth: isSameMonth(date, currentDate),
        currDate: isSameDate(date, currentDate),
        prevMonth: isLowerMonthThan(date, currentDate),
        nextMonth: isHigherMonthThan(date, currentDate),
        weekDay: dayOfWeek(date)
    }
}

module.exports = getDateProps;
},{"./dayOfWeek":5,"./isHigherMonthThan":21,"./isLowerMonthThan":22,"./isSameDate":23,"./isSameMonth":24}],21:[function(require,module,exports){
function isHigherMonthThan(date1, date2) {
    if (date1.getFullYear() > date2.getFullYear()) {
        return true;
    }
    else if (date1.getFullYear() == date2.getFullYear()) {
        if (date1.getMonth() > date2.getMonth()) {
            return true;
        }
    }
    return false;
}

module.exports = isHigherMonthThan;
},{}],22:[function(require,module,exports){
function isLowerMonthThan(date1, date2) {
    if (date1.getFullYear() < date2.getFullYear()) {
        return true;
    }
    else if (date1.getFullYear() == date2.getFullYear()) {
        if (date1.getMonth() < date2.getMonth()) {
            return true;
        }
    }
    return false;
}

module.exports = isLowerMonthThan;
},{}],23:[function(require,module,exports){
function isSameDate(date1, date2) {
    if (date1.getFullYear() == date2.getFullYear() && date1.getMonth() == date2.getMonth() && date1.getDate() == date2.getDate()) {
        return true;
    }
    return false;
}

module.exports = isSameDate;
},{}],24:[function(require,module,exports){
function isSameMonth(date1, date2) {
    if (date1.getFullYear() == date2.getFullYear() && date1.getMonth() == date2.getMonth()) {
        return true;
    }
    return false;
}

module.exports = isSameMonth;
},{}],25:[function(require,module,exports){
var weekStructure = require('./weekStructure');
var addDays = require('./addDays');

function monthStructure(date) {
    if (typeof date == 'undefined') {
        date = new Date();
    }

    var s = [], d = new Date(date.getTime());

    // Uzlieka mēneša sākumu
    d.setDate(1)

    // Veidojam struktūru ar 6 nedēļām
    for (var i = 0; i < 6; i++) {
        
        s.push(weekStructure(d))

        d = addDays(d, 7);
    }

    return s;
}

module.exports = monthStructure;
},{"./addDays":1,"./weekStructure":28}],26:[function(require,module,exports){
function properties(props) {
    this.props = typeof props == 'undefined' ? {} : props;
}

properties.prototype = {
    get: function(propName, defaultValue) {
        if (typeof this.props[propName] == 'undefined') {
            return defaultValue;
        }

        return this.props[propName];
    }
}

module.exports = properties
},{}],27:[function(require,module,exports){
var getDateProps = require('./getDateProps');

function setMonthStructureDatesProps(structure, currentDate) {
    for (var w = 0; w < structure.length; w++) {
        for (var d = 0; d < structure[w].length; d++) {
            structure[w][d] = {
                date: structure[w][d],
                dateProps: getDateProps(structure[w][d], currentDate)
            }
        }
    }

    return structure;
}

module.exports = setMonthStructureDatesProps;
},{"./getDateProps":20}],28:[function(require,module,exports){
var addDays = require('./addDays');
var dayOfWeek = require('./dayOfWeek')

function weekStructure(date) {
    if (date == 'undefined') {
        date = new Date();
    }

    var s = [], start = -dayOfWeek(date);

    // Savācam masīvu ar dienu datumiem
    for (var i = 0; i <= 6; i++) {
        s.push(addDays(date, ++start));
    }

    return s;
}

module.exports = weekStructure;
},{"./addDays":1,"./dayOfWeek":5}],29:[function(require,module,exports){
function isjQuery(obj) {
    // Pārbaudām vai ir globālais jQuery objekts
    if (typeof jQuery != 'undefined') {
        return obj instanceof jQuery;
    }
    
    if (obj && typeof obj.jquery != 'undefined') {
        return true;
    }

    return false;
}

function isArray(obj) {
    return (
        Object.prototype.toString.call(obj) === '[object Array]'
        || Object.prototype.toString.call(obj) === '[object HTMLCollection]'
        || Object.prototype.toString.call(obj) === '[object NodeList]'
    );
}


/**
 * jQuery, DOM or array items collection
 */
function elementsCollection(items) {
    this.items = items;

    this.itemsType = '';

    if (isjQuery(this.items)) {
        this.itemsType = 'jquery';
    }
    else if (isArray(this.items)) {
        this.itemsType = 'array';
    }
}

elementsCollection.prototype = {
    each: function(cb) {
        switch (this.itemsType) {
            case 'jquery':
                this.items.each(function(i){
                    cb(this, i)
                });
                break;
            case 'array':
                for (var i = 0; i < this.items.length; i++) {
                    cb(this.items[i], i);
                }
                break;
        }
    }
}

module.exports = elementsCollection
},{}],30:[function(require,module,exports){
function getStyleDimensions(style, name) {
    return parseInt(style.getPropertyValue(name), 10);
}

function getElementDimensions(el) {
    var s = getComputedStyle(el);

    // Noņemam border width
    var borderHorizontal = getStyleDimensions(s, 'border-left-width') + getStyleDimensions(s, 'border-right-width');
    var borderVertical = getStyleDimensions(s, 'border-top-width') + getStyleDimensions(s, 'border-bottom-width');

    // Noņemam padding width
    var paddingHorizontal = getStyleDimensions(s, 'padding-left') + getStyleDimensions(s, 'padding-right');
    var paddingVertical = getStyleDimensions(s, 'padding-top') + getStyleDimensions(s, 'padding-bottom');

    if (typeof el.getBoundingClientRect != 'undefined') {
        var rect = el.getBoundingClientRect();
        if (typeof rect.width != 'undefined' && typeof rect.height != 'undefined') {
            return {
                width: rect.width - borderHorizontal - paddingHorizontal,
                height: rect.height - borderVertical - paddingVertical
            }
        }
    }

    return {
        width: el.offsetWidth - borderHorizontal - paddingHorizontal,
        height: el.offsetHeight - borderVertical - paddingVertical
    }
}

module.exports = getElementDimensions;
},{}],31:[function(require,module,exports){
function getStyleDimensions(style, name) {
    return parseInt(style.getPropertyValue(name), 10);
}

function getElementOuterDimensions(el, includeMargin) {
    includeMargin = typeof includeMargin == 'undefined' ? false : includeMargin;

    var s = getComputedStyle(el);

    var marginHorizontal = 0;
    var marginVertical = 0;
    if (includeMargin) {
        marginHorizontal = getStyleDimensions(s, 'margin-left') + getStyleDimensions(s, 'margin-right');
        marginVertical = getStyleDimensions(s, 'margin-top') + getStyleDimensions(s, 'margin-bottom');    
    }

    if (typeof el.getBoundingClientRect != 'undefined') {
        var rect = el.getBoundingClientRect();
        if (typeof rect.width != 'undefined' && typeof rect.height != 'undefined') {
            return {
                width: rect.width + marginHorizontal,
                height: rect.height + marginVertical,

                marginH: marginHorizontal,
                marginV: marginVertical
            }
        }
    }

    return {
        width: el.offsetWidth + marginHorizontal,
        height: el.offsetHeight + marginVertical,

        marginH: marginHorizontal,
        marginV: marginVertical
    }
}

module.exports = getElementOuterDimensions;
},{}],32:[function(require,module,exports){
var Swipe = require('swipe');
var Stepper = require('stepper');
var Slides = require('./slides');
var getElementDimensions = require('./getElementDimensions');

function createSwipe(el, $slides, conf) {
    var slideAddCb, changeCb, pagesCountCb, slideMoveCb = function(){}, slideMoveStartCb = function(){};
    var slides, stepper, viewportWidth = 0, startMoveSlide;
    var startPos = 0, offsetX = 0, isMoveStarted = false;
    var stepperCurve = [0,0,.12,1];
    var stepperDuration = 300;

    var rotateItems = getRotateItems();

    // Pēc noklusējuma viss ir enbabled, bet ir iespēja uz mirkli atslēgt touch eventus
    var isEnabled = true;

    function initSwipe() {
        new Swipe(getSwipeTarget(), {'direction': 'horizontal'})
            .on('start', startMove)
            .on('move', handleMove)
            .on('touchend', endMove) 
    }

    function initSlides() {
        slides = new Slides($slides, viewportWidth, {
            onSlideAdd: handleSlideAdd,
            slidesPadding: getSlidesPadding,
            positionItems: getPositionItems(),
            rotateItems: getRotateItems(),
            onPagesCount: function(c){
                if (pagesCountCb) {
                    pagesCountCb(c)
                }
            }
        });
    }

    function initStepper() {
        stepper = new Stepper({
            bezierCurve: stepperCurve
        });
    }

    function startMove(d) {
        if (!isEnabled) {
            return;
        }

        if (stepper.isRunning()) {
            stepper.stop();
        }

        // Pieglabājam current slide, no kura tika sākta kustība
        startMoveSlide = getCurrent();

        slides.start();
        isMoveStarted = true;

        slideMoveStartCb(d.touchedElement ? true : false);
    }

    function handleMove(d) {    
        if (!isEnabled) {
            return;
        }

        if (stepper.isRunning()) {
            return;
        }

        if (!isMoveStarted) {
            return;
        }

        slideMoveCb(Math.abs(d.offset.x) / viewportWidth, d.direction, d.touchedElement ? true : false);

        /**
         * Ja nav jārotē items, tad jāčeko vai ir pienācis 
         * laiks apstādināt items pārvietošanos un jāsāk bremzēšana
         * Tipa elastic scroll
         *
         * slides.getLast().getX() + getLast().width - ja šis ir mazāks par view[port width
         * slides.getFirst().getX() - lielāks par nulli
         */
        if (!rotateItems) {
            slides.setXOffset(
                // Aprēķinām kāds ir slide out platums un to bremzējam
                // lai iegūtu elastic swipe efektu
                // bremzējam tikai slide out vērtību
                d.offset.x - getSlideOutXWidth(d.offset.x)*0.75
            );
        }
        else {
            slides.setXOffset(d.offset.x);
        }
    }

    function endMove(d) {
        if (!isEnabled) {
            return;
        }
        
        if (!isMoveStarted) {
            return;
        }

        isMoveStarted = false;

        /**
         * Pārbaudām vai ir offset. Ja ir bijis tikai click, tad
         * offset nebūs. Šādu endMove ignorējam
         */
        if (!d.offset) {
            return;
        }

        snapSlide(
            // Šeit ņemam vērā isSwipe, lai saprastu uz kuru slide snapot    
            getSnapTarget(getSlideToSnapByEndMove(d)),

            d.isSwipe, 
            d.touchedElement ? true : false,

            // Kāda ir manualMove distance
            // kādas ir virziens
            {
                offset: Math.abs(d.offset.x),
                direction: d.direction
            }
        );
    }

    function getSlideOutXWidth(offsetX) {
        var f = getFirstSlideOutWidth(offsetX);
        var l = getLastSlideOutWidth(offsetX);

        if (f > 0) {
            return f;
        }

        if (l > 0) {
            return -l;
        }

        return 0;
    }

    /**
     * Tiek izmantota tikai no rotate gadījumā
     * Vai pirmais slide tiek skrollēts pāri 
     * savām robežām
     */
    function isFirstSlideOut(offsetX) {
        return getFirstSlideOutWidth(offsetX) > 0
    }
    function getFirstSlideOutWidth(offsetX) {
        
        var x = slides.first().getX();
        if (typeof offsetX != 'undefined') {
            x = slides.first().getXWithoutOffset() + offsetX;    
        }
        
        if (x > 0) {
            return x;
        }
        return 0;
    }

    function isLastSlideOut(offsetX) {
        return getLastSlideOutWidth(offsetX) > 0
    }
    function getLastSlideOutWidth(offsetX) {
        var r = slides.last();

        var x = r.getX() + r.width;
        if (typeof offsetX != 'undefined') {
            x = r.getXWithoutOffset() + r.width + offsetX;
        }

        if (x <  viewportWidth) {
            return viewportWidth - x;
        }
        return 0;
    }

    function getSlideToSnapByEndMove(d) {
        // Rotēšana atslēgta
        if (!rotateItems) {
            /**
             * Snap uz to slide, kurš ir ārpus zonas
             * 
             * Ja neviens slide nav ārpus zonas, tad
             * izpildīsies parastais scenārijs pēc 
             * swipe kustības
             */
            if (isFirstSlideOut()) {
                return slides.first();
            }
            else if (isLastSlideOut()) {
                return slides.last();
            }
        }


        /**
         * Kāda daļa no pārbīdāmā slide jau ir pārbīdīta
         * Tas vajadzīgs, lai gadījumā ja tikai nedaudz pabīdīts, tad
         * atliktu atpakaļ, tas ir, lietotājs nemaz negribēja pārbīdīt
         * Ja ratio lielāks par 0.333, tad lietotājs gribēja bīdīt
         * Kaut gan šeit mazākiem slaidiem varbūt 0.33 ir maz???
         */
        var moveRatio = Math.abs(d.offset.x / startMoveSlide.width)

        // Ja direction left, tad tuvāko slide labajai malai
        if (d.direction == 'left') {
            if (d.isSwipe || moveRatio > 0.33333) {
                return slides.findClosestToXFromRight(0)
            }
            else {
                return slides.findClosestToXFromLeft(0)
            }
        }
        else {
            if (d.isSwipe || moveRatio > 0.33333) {
                return slides.findClosestToXFromLeft(0)
            }
            else {
                return slides.findClosestToXFromRight(0)   
            }
        }
    }

    /**
     * Atgriež x, y pozīciju uz kuru snapot
     * padoto slide. Ja slide vajag snapot pret  
     * lano malu, tad snap target būs 0
     * Ja vajag pret kreiso malu, tad viewportWidth - slide.width
     *
     * Te tiek ņemta vērā rotateItems pazīme, pēc tās tiek noteiks
     * vai snapot uz kreiso vai labo pusi
     *
     * Jāņem vērā vai snap uz norādīto target neuztaisīs slideOut
     * gadījumu. Ja tā ir, tad vajag piekoriģēt snapTarget, lai tā
     * nenotiku
     */
    function getSlideSnapPosition(slideToSnap) {
        /**
         * By default snapojam slide kreiso malu 
         * pie viewport kreisās malas
         *
         * @todo Uztaisīt, lai var nodefinēt pret kuru 
         * malu snapot slide
         */
        if (rotateItems) {
            return {
                x: 0,
                y: undefined
            }
        }

        /**
         * Slides netiek rotēti, šeit jāsāk pārbaudīt
         * gadījumi, kad pirmais vai pēdējais slide iet
         * ārpus viewport dimensijām
         */
        if (isLastSlideOut()) {
            // Pēdējā slide labajai malai ir jānostājas līdz ar viewport labo malu
            return {
                x: viewportWidth - slides.last().width,
                y: undefined
            }
        }

        if (isFirstSlideOut()) {
            // Pirmā slide kreisā mala pret viewport kreiso malu
            return {
                x: 0,
                y: undefined
            }
        }

        /**
         * Jāpārbauda vai pēc slide snap netiks uztaisīt 
         * slide out situācija
         *
         * Šādi parasti notiek ar pēdējo slide
         * @todod bet vajag uztaisīt check arī uz pirmo slide
         */

        // Pēc noklusējuma snapojam slide uz 0 pozīciju
        var d = (slides.last().getX() + slides.last().width) - viewportWidth;
        
        return {
            x: Math.max(0, slideToSnap.getX() - d),
            y: undefined
        }
    }

    function getSnapTarget(slide) {
        return {
            slide: slide,
            to: getSlideSnapPosition(slide)
        }
    }

    /**
     * Nofiksējam target.slide pret norādīto target.to.x pozīciju
     */
    function snapSlide(target, isSwipe, isTouch, manualMove) {

        if (typeof isSwipe == 'undefined') {
            isSwipe = false;
        }
        if (typeof isTouch == 'undefined') {
            isTouch = false;
        }

        slides.start();

        /**
         * Aprēķinām kādu vajag offset, lai pārvietotos no getX uz target.to.x
         * Kad progress ir 0, tad offset atteicīgi arī ir 0
         * Kad progress ir 1, tad tas offset ir attālums starp target.slide.getX un target.to.x
         */
        var targetOffset = target.to.x - target.slide.getX();
        var targetDirection = targetOffset > 0 ? 'right' : 'left';

        var startProgress = 0;
        var pv = 0;
        var slideMoveProgress = 0;

        stepper.runFrom(startProgress, {
            duration: stepperDuration,
            onStep: function(progress){
            
                pv = progressToValue(progress, 0, targetOffset);

                slides.setXOffset(pv);

                /**
                 * Ja snap slides notiek tajā pašā virzienā, kā bija move kustība, tad
                 * progresēja uz 1
                 * Ja snap slides notiek atpakaļ, tad progresējam uz 0
                 * SlideMoveCb vienmēr dodam progrss turpinājumu
                 * Tas progress, kad ir te ir cits - tas ir progress no 0 līdz vietai, kura vajag snap slide
                 * Tāpēc šeit savādāk rēķinām progresus
                 * Šeit ņemam to abs(offset) kādu veica lietotājs un liekam klāt to offset kādu vajag, lai 
                 * slaidi uztaisīt snap savā vietā
                 * Ja virzieni sakrīt (lietotāja move un slidesnap), tad progresējam
                 * Ja nē, tad regresējam atpakaļ uz sākumu
                 */
                if (manualMove) {
                    // Turpinām progresu, lai tas uzaug līdz 1, jo snap turpina tajā pašā virzienā
                    if (manualMove.direction == targetDirection) {
                        slideMoveProgress = manualMove.offset + Math.abs(pv)
                    }
                    // Ejam atpakaļ uz izejas pozīciju, regresējam
                    else {
                        slideMoveProgress = manualMove.offset + (-Math.abs(pv))
                    }
                    // Progress ir pārvietojums pret viewport platumu
                    slideMoveProgress = slideMoveProgress / viewportWidth;
                }
                // Kustība notiek bez manuāli iesāktas kustības
                else {
                    slideMoveProgress = progress
                }

                slideMoveCb(slideMoveProgress, targetDirection, false);

            }, 
            onDone: function() {
                slideSnapTransitionDone({
                    isSwipe: isSwipe, 
                    isTouch: isTouch
                });
            }
        })
    }

    function progressToValue(progress, fromValue, toValue) {
        var w = fromValue - toValue;
        return fromValue - (w * progress);
    }

    function validateProgress(p) {
        if (p < 0) {
            p = 0;
        }
        if (p > 1) {
            p = 1;
        }
        return p;
    }

    function slideSnapTransitionDone(params) {
        if (typeof changeCb != 'undefined') {
            changeCb(params);
        }
    }

    function getCurrent() {
        return slides.findFirstBetweenX(-1, viewportWidth);
    }

    function getNext() {
        return slides.findClosestToXFromRight(getCurrent().getX()+1);
    }

    function getPrev() {
        return slides.findClosestToXFromLeft(getCurrent().getX() - 1);
    }

    function getSwipeTarget() {
        if (conf && conf.swipeTarget) {
            return conf.swipeTarget;
        }
        return el;
    }

    function getSlidesPadding() {
        if (conf && typeof conf.slidesPadding != 'undefined') {
            if (typeof conf.slidesPadding == 'function') {
                return conf.slidesPadding();
            }
            else {
                return conf.slidesPadding;
            }
        }

        return 0;
    }

    function getPositionItems() {
        if (conf && typeof conf.positionItems != 'undefined') {
            return conf.positionItems;
        }
        return false;
    }

    /**
     * Config params vai slaidus vajag rotēt
     * Pēc noklusējuma vajag rotēt
     *
     * @todo Varbūt tomēr nevajag rotēt pēc noklusējuma
     *
     */
    function getRotateItems() {
        if (conf && typeof conf.rotate != 'undefined') {
            return conf.rotate;
        }
        return true;
    }

    function handleSlideAdd(index, el) {
        if (slideAddCb) {
            slideAddCb(index, el);
        }
    }

    function setIsEnabled(s) {
        isEnabled = s;
    }

    function handleResize() {
        viewportWidth = getElementDimensions(el).width;

        if (slides) {
            slides.setViewportWidth(viewportWidth);
            slides.resize();
        }
    }

    // Liekam timeout, lai izpildās nākamajā scope
    // Vajag, lai izsaucošais kods var uzlikt onSlideAdd pirms tam
    setTimeout(function(){
        handleResize();
        initSwipe();
        initSlides();
        initStepper();
    });

    return {
        onSlideAdd: function(cb) {
            slideAddCb = cb;
        },
        onChange: function(cb) {
            changeCb = cb;
        },
        onPagesCount: function(cb) {
            pagesCountCb = cb;
        },
        onSlideMoveStart: function(cb) {
            slideMoveStartCb = cb
        },
        /**
         * Slide kustība. Lai var slide kustību sinhronizēt
         * ar kādu citu elementu
         */
        onSlideMove: function(cb) {
            slideMoveCb = cb
        },
        restart: function() {
            slides.reset();
        },
        nextSlide: function() {
            slideMoveStartCb(false);

            if (getNext()) {
                snapSlide(getSnapTarget(getNext()));
            }
        },
        prevSlide: function() {
            slideMoveStartCb(false);

            if (getPrev()) {
                snapSlide(getSnapTarget(getPrev()));
            }
        },
        nextPage: function() {

        },
        prevPage: function() {

        },
        showSlide: function(index) {
            slides.showByIndex(index);
        },
        getCurrent: getCurrent,
        getNext: getNext,
        getPrev: getPrev,
        getSlides: function() {
            return slides;
        },
        disable: function() {
            setIsEnabled(false);
        },
        enable: function() {
            setIsEnabled(true);
        },
        resize: function() {
            handleResize();
        }
    }
}


module.exports = function(el, $slides, conf) {
    return createSwipe(el, $slides, conf);
}
},{"./getElementDimensions":30,"./slides":37,"stepper":34,"swipe":35}],33:[function(require,module,exports){
var b = function(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    var cx = 3.0 * p1x;
    var bx = 3.0 * (p2x - p1x) - cx;
    var ax = 1.0 - cx -bx;
         
    var cy = 3.0 * p1y;
    var by = 3.0 * (p2y - p1y) - cy;
    var ay = 1.0 - cy - by;

    var epsilon = 0.00001;

    function sampleCurveDerivativeX(t) {
        return (3.0 * ax * t + 2.0 * bx) * t + cx;
    }

    function sampleCurveX(t) {
        // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
        return ((ax * t + bx) * t + cx) * t;
    }

    function sampleCurveY(t) {
        return ((ay * t + by) * t + cy) * t;
    }

    // Given an x value, find a parametric value it came from.
    function solveCurveX(x)
    {
        var t0, t1, t2, x2, d2, i;

        // First try a few iterations of Newton's method -- normally very fast.
        for (t2 = x, i = 0; i < 8; i++) {
            x2 = sampleCurveX(t2) - x;
            if (Math.abs(x2) < epsilon) {
                return t2;
            }
            d2 = sampleCurveDerivativeX(t2);
            if (Math.abs(d2) < 1e-6) {
                break;
            }
            t2 = t2 - x2 / d2;
        }

        // Fall back to the bisection method for reliability.
        t0 = 0.0;
        t1 = 1.0;
        t2 = x;

        if (t2 < t0) {
            return t0;
        }
        if (t2 > t1) {
            return t1;
        }

        while (t0 < t1) {
            x2 = sampleCurveX(t2);
            if (Math.abs(x2 - x) < epsilon) {
                return t2;
            }
            if (x > x2) {
                t0 = t2;
            }
            else {
                t1 = t2;
            }
            t2 = (t1 - t0) * .5 + t0;
        }

        // Failure.
        return t2;
    }

    this.get = function(x) {
        return sampleCurveY(solveCurveX(x));
    }
}

module.exports = b;
},{}],34:[function(require,module,exports){
//var Bezier = require('./bezier1.js');
/**
 * See https://easings.net
 */
var Bezier = require('./bezier2.js');

var Stepper = function(config) {
    this.defaultBezierCurve = [0,0,1,1];
    this.precision = 10000000;
    this.progress = 0;
    this.current = 0;
    this.requestId = 0;
    this.inProgress = false;
    /**
     * Vērtība, kuru transformēt atbilstoši progress vērtībai
     * @param object object with props: from, to
     */
    this.value = undefined;

    this.config = config;

    this.setConfig();
}

Stepper.prototype = {
    setConfig: function(overrideConfig) {
        this.duration = this.getConfig('duration', overrideConfig);
        this.easing = this.getConfig('bezierCurve', overrideConfig);
        this.value = this.getConfig('value', overrideConfig);
        

        this.stepCallback = this.getConfig('onStep', overrideConfig);
        this.doneCallback = this.getConfig('onDone', overrideConfig);
        this.forceStopCallback = this.getConfig('onForceStop', overrideConfig);
    },

    run: function(overrideConfig) {
        this.setConfig(overrideConfig);

        this.current = 0;

        this.start();
        this.step();
    },

    /**
     * Run from given progress
     */
    runFrom: function(progress, overrideConfig) {
        this.setConfig(overrideConfig);

        /**
         * Šeit ir svarīgs moments
         * Padotais progress ir tāds, kādu gribam
         * bet easing aprēķinātais progress esošajā progress ir savādāk, jo 
         * tas ir curve un tas nav lineārs
         * Tāpēc šeit atrodam kādam ir jābūt progresam pēc easing
         *
         * Update pēc kāda laika lietošanas
         * Tomēr škiet, ka to nemaz nevajag darīt, jo ja es gribu sākt no
         * 0.9 progresa un duration ir 1000ms, tad es gribu, lai animācija
         * ir 100ms gara. Ja pārrēķina progresu, tad animācijas garums ir 
         * garāks vai īsāks
         */
        //progress = this.findStartProgress(progress, 0.1, 0, 1);
        
        this.startTime = +new Date();
        // Simulējam startTime, tā lai tas būtu sācies pirms norādītā progress
        this.startTime -= (this.duration * progress);
        // Turpinām no padotā progress
        this.progress = progress;

        this.inProgress = true;

        this.step();
    },

    /**
     * Meklējam kādam ir jābūt progress, lai pēc easing.get tas būt tāds pats kā progress
     */
    // findStartProgress: function(progress, step, from, to, inceptionLevel) {

    //     if (typeof inceptionLevel == 'undefined') {
    //         inceptionLevel = 0;
    //     }
        
    //     var d = from, prevR = 0, prevD;

    //     while (d < to) {
    //         // Lai ir lielāka precizitāte
    //         if (inceptionLevel++ > 100) {
    //             return d;
    //         }

    //         r = this.easing.get(d);

    //         if (Math.round(progress*this.precision) == Math.round(r*this.precision)) {
    //             return d;
    //         }

    //         if (this.isBetween(progress, prevR, r)) {
    //             return this.findStartProgress(progress, step/10, prevD, d, inceptionLevel);
    //         }

    //         prevD = d;
    //         prevR = r;
    //         d += step;
    //     }

    //     return d;
    // },

    /**
     * Is a between x1 and x2
     */
    // isBetween: function(a, x1, x2) {
    //     if (x2 > x1) {
    //         return a > x1 && a < x2;
    //     }
    //     return a > x2 && a < x1;
    // },

    isRunning: function() {
        return this.inProgress;
    },

    /**
     * Piefiksējam sākuma laiku
     */
    start: function() {
        this.inProgress = true;
        this.startTime = +new Date();
        this.progress = 0;
    },

    /**
     * Pārtraucam stepping
     */
    stop: function() {
        cancelAnimationFrame(this.requestId);
        this.done();
    },

    /**
     * Pārtraucam animāciju un neizpildām done callback
     */
    forceStop: function() {
        cancelAnimationFrame(this.requestId);
        this.inProgress = false;
        if (this.forceStopCallback) {
            this.forceStopCallback();
        }
    },

    done: function() {
        this.inProgress = false;
        if (this.doneCallback) {
            this.doneCallback();
        }
    },

    step: function() {
        var mthis = this;

        mthis.trackProgress();

        if (this.current < this.startTime + this.duration) {

            this.runStepCallback(this.progress);

            this.requestId = requestAnimationFrame(function(){
                mthis.step()
            });
        }
        else {
            this.runStepCallback(1);

            this.done();
        }
    },

    trackProgress: function() {
        // Current time
        this.current = +new Date();

        var delta = this.current - this.startTime;

        // Animation progress in precents
        this.progress = this.easing.get(delta / this.duration);

        //this.progress = Math.round(this.progress*this.precision)/this.precision;
    },

    runStepCallback: function(progress) {
        // Ja ir jāaprēķina vērtība atkarībā no progress
        if (this.value) {
            this.stepCallback(progress, this.calcValueFromProgress(progress, this.value.from, this.value.to))
        }
        else {
            this.stepCallback(progress)
        }
    },

    calcValueFromProgress: function(progress, from, to) {
        return from + ((to - from) * progress);
    },

    getEasing: function(bezierCurve) {
        if (!(bezierCurve && bezierCurve.length && bezierCurve.length == 4)) {
            bezierCurve = this.defaultBezierCurve;
        }
        return new Bezier(bezierCurve[0], bezierCurve[1], bezierCurve[2], bezierCurve[3]);
    },

    /**
     * Atgriežam config vērtību.
     * Katrai vērtībai pēc tās name tiek veiktas pārbaudes vai papildus apstrāde
     * @param secondaryConfig object Alternate override config vērtības
     */
    getConfig: function(name, secondaryConfig) {
        var r = this.getConfigValue(name, secondaryConfig);
        switch (name) {
            case 'bezierCurve':
                r = this.getEasing(r);
                break;
            case 'duration':
                r = parseInt(r, 10);
                r = isNaN(r) ? 200 : r;
                break;
            case 'onStep':
            case 'onDone':
            case 'onForceStop':
                r = typeof r == 'function' ? r : function(){}
                break;
            case 'value':
                if (!(r && typeof r == 'object' && typeof r['from'] != 'unefined' && r['to'] != 'undefined')) {
                    r = undefined;
                }
                break;
        }
        
        return r;
    },

    getConfigValue: function(name, secondaryConfig) {
        // Pirmo meklējam sekundārajā konfigā
        if (secondaryConfig && typeof secondaryConfig[name] != 'undefined') {
            return secondaryConfig[name];
        }

        // Meklējam bāzes konfigā
        if (this.config && typeof this.config[name] != 'undefined') {
            return this.config[name];
        }

        return undefined;
    }
}

module.exports = Stepper;
},{"./bezier2.js":33}],35:[function(require,module,exports){
(function(root, factory){

    if (typeof exports === 'object') {
        module.exports = factory();
    }
    else {
        if (typeof root.webit == 'undefined') {
            root.webit = {}
        }
        root.webit.swipe = factory();
    }

})(this, function(){

    var instances = 0;

    var List = function(items) {
        this.items = items;
    }
    List.prototype = {
        first: function() {
            if (this.items.length > 0) {
                return this.items[0];
            }
            return false;
        },
        second: function() {
            if (this.items.length > 1) {
                return this.items[1];
            }
            return false;
        }
    }

    var Swipe = function(el, config) {
        this.instanceId = instances++;


        // Touch/mouse events will be attaches to body
        this.swipeEl = document.getElementsByTagName('body')[0];

        this.el = el;

        this.events = this.prepareEvents([
            'swipe', 'move', 'start', 'end', 
            'pinchstart', 'pinchend', 'pinchmove', 
            'touchend', 'touchmove',
            'tap', 'doubletap'
        ]);

        // Apply configuration
        this.config(config);

        this.setTouchAction(this._config.direction);

        // Visi reģistrētie touchi, pēc to identifikatoriem
        this.touches = {};
        // Piereģistrēto touch skaits
        this.touchesCount = 0;
        // Slope factor to distinguise vertical swipe from horizontal
        this.slopeFactor = 1;
        // First touch when touch start occures
        this.startTouches = false;
        // First touch when first move event triggered
        this.firstMoveTouches = false;
        // Current touch, when swipe is in process
        this.currentTouches = false;

        // Swipe width
        this.width;
        // Swipe height
        this.height;
        // Swipe duration
        this.duration;
        // In case of directional swipe, this will be initial swipe direction (horizontal or vertical)
        this.moveDirection = null;

        // Cik pēdējās swipe kustības uzkrāt, lai noteiktu vai ir bijis swipe
        this.swipeLogStackMaxLength = 4;

        this.swipeLog = {
            stack: [],
            duration: 0,
            width: 0,
            height: 0
        };

        /**
         * Taps logs. Katram touch eventam piereģistrējam sākuma un beigu laiku
         * Pēc tam analizējam taps ilgumu un meklējam starp tiem tap vai double Tap
         * 
         * Reģistrējot pārbaudam vai events ar norādīt id ir reģistrēts. Ja nav tad liekam iekšā
         * un piereģistrējam ienākšanas laiku
         * 
         * Atreģistrējot meklējam eventu, kuram nav endTime
         */
        this.tapsLog = {};
        this.waitForDoubleTap = false;
        this.tapsLogExecuteTimeout = 0;

        /**
         * Is touch events supported
         * This will be determined when first touchstart event fires
         */
        this.isTouchEvents = false;

        /**
         * Is touch started on this.el
         */
        this.isTouchedValidElement = false;

        // Mouse down event
        this.isMouseDown = undefined;

        this.handleEvents('add');

        return this;
    }

    Swipe.prototype = {
        prepareEvents: function(eventNames) {
            var r = {};
            for ( var i in eventNames ) {
                r[eventNames[i]] = [];
            }
            return r;
        },

        handleEvents: function(method) {
            var mthis = this;

            var start = function(ev) {
                // Reģistrēti tiek tikai tie touchi, kuri nāk no iekonfigurētā elementa
                mthis.registerTouches(ev, true);

                mthis.isTouchedValidElement = mthis.touchesCount > 0;
                if (mthis.isTouchedValidElement) {
                    mthis._start(ev);
                }
            }
            
            var end = function(ev) {
                if (mthis.isTouchedValidElement) {
                    mthis._end(ev);
                    mthis.isTouchedValidElement = false;
                }

                mthis.unregisterTouches(ev);

                // Pārbaudām vai var palaist tap vai double tap eventus
                mthis.maybeFireTapping();
            }

            /**
             * @param touchedElement is used only on case of mouse
             * it provides custom element, not the one from current touch
             */
            var move = function(ev) {
                mthis.registerTouches(ev);

                if (mthis.isTouchedValidElement) {
                    mthis._move(ev);
                }
            }

            
            // Ja izpildīsies touchstart, tad mouse eventus vairāk neklausāmies
            var touchStart = function(ev) {
                mthis.isTouchEvents = true;
                start(ev);
            }

            var touchEnd = function(ev) {
                end(ev);
            }

            var touchMove = function(ev) {
                move(ev)
            }


            // Ja ir toucheventi, tad mouse eventus neizpildām
            var _mouseMove;

            var isMouseMove = function(startEv, moveEv) {
                if (startEv.x != moveEv.x) {
                    return true;
                }

                if (startEv.y != moveEv.y) {
                    return true;
                }

                return false;
            }

            var mouseStart = function(ev) {
                /**
                 * Right mouse button causes to fire mouseStart but no 
                 * mouseEnd because of context menu which is fired on
                 * right mouse click and mouseEnd event is not catched
                 * So only react to left mouse click
                 */
                if (!mthis.isMainMouseButton(ev)) {
                    return;
                }

                mthis.isMouseDown = mthis.formatTouch(ev);

                if (!mthis.isTouchEvents) {
                    start(ev)   
                }
            }

            var mouseEnd = function(ev) {
                if (!mthis.isTouchEvents) {
                    end(ev) 
                }
                mthis.isMouseDown = undefined;
            }

            var mouseMove = function(ev) {
                if (!mthis.isTouchEvents) {
                    if (mthis.isMouseDown) {
                        if (isMouseMove(mthis.isMouseDown, mthis.formatTouch(ev))) {
                            move(ev)
                        }
                    }
                }
            }

            var eventMethod = method == 'add' ? 'addEvent' : 'removeEvent';

            this[eventMethod](this.swipeEl, 'touchstart', touchStart);
            this[eventMethod](this.swipeEl, 'touchmove', touchMove, {passive: false});
            this[eventMethod](this.swipeEl, 'touchend', touchEnd);
        
            this[eventMethod](this.swipeEl, 'mousedown', mouseStart);
            this[eventMethod](this.swipeEl, 'mousemove', mouseMove);
            this[eventMethod](this.swipeEl, 'mouseup', mouseEnd);
        },

        /**
         * Touch start. When touch starts or when mouse down
         */
        _start: function(ev) {

            if (this._config.alwaysPreventTouchStart) {
                this.preventEvent(ev);
            }

            // Touch stāvoklis pašā sākumā
            this.startTouches = this.getTouches();

            // Touch stāvoklis, kad notika pirmais touchMove
            this.firstMoveTouches = false;

            this.validMove = false;
            this.moveDirection = null;
            this.swipeLog.stack = [];

            this.fire('start', [this.startTouches.first()]);

            // retranslate pinch
            this.maybeFirePinchStart();
        },

        /**
         * Touch ends
         */
        _end: function(ev) {
            this.currentTouches = this.getTouches();

            this.trackDuration();
            this.trackSwipe();

            var movement = this.formatMovement();

            // Liekam swipe statusu
            movement._swipeLog = {
                duration: this.swipeLog.duration,
                width: this.swipeLog.width,
                height: this.swipeLog.height,
                stackLength: this.swipeLog.stack.lenght,
                isSwipe: false
            };
            
            /**
             * Šeit pēc duration, width un height nosakām vai tā varēja
             * būt swipe kustība. Varbūt atkarībā no iekārtas varētu šo 
             * parametrus piekoriģēt???
             */
            if (this.swipeLog.duration < 80) {
                if (this.swipeLog.width > 7 || this.swipeLog.height > 7) {
                    movement._swipeLog.isSwipe = true;
                }
            }

            // Pazīme, vai bija swipe kustība
            movement.isSwipe = movement._swipeLog.isSwipe;


            this.startTouches = false;
            this.firstMoveTouches = false;

            if (this.validMove) {
                this.fire("end", [movement]);
             }

            // Vienmēr izpildām touchend eventu
            this.fire("touchend", [movement]);

            // retranslate pinch
            this.maybeFirePinchEnd();
        },

        /**
         * Touch is moving. Moving when mouse down
         */
        _move: function(ev) {

            if (this.startTouches) {

                // If configured to disable pinch to zoom
                this.maybePreventPinch(ev);

                if (!this.firstMoveTouches) {
                    this.firstMoveTouches = this.getTouches();
                }

                this.currentTouches = this.getTouches();

                this.clearTapLog();
                this.trackDuration();
                this.trackSwipe();
                this.trackMovment();

                // Always retranslate touchmove if there was move
                this.fireTouchMove();

                if (this.isValidMove()) {
                    this.preventEvent(ev);
                    this.validMove = true;
                }
                else {
                    this.validMove = false;   
                }
                
                if (this.validMove) {
                    this.fire('move', [this.formatMovement()])
                }

                // retranslate pinch
                this.maybeFirePinchMove();
            }
        },

        /**
         * Pārbaudām vai var palaist tap vai doubletap eventus
         */
        maybeFireTapping: function() {
            clearTimeout(this.tapsLogExecuteTimeout);

            if (this.isEventsRegistered('doubletap')) {
                this.maybeFireDoubleTap(this.getValidTapRegistered());
            }
            else {
                this.maybeFireSingleTap(this.getValidTapRegistered());
            }

            this.clearTapLog();            
        },

        maybeFireDoubleTap: function(tap) {
            if (!tap) {
                return;
            }

            var mthis = this;

            if (this.waitForDoubleTap) {
                this.fire('doubletap', [tap.touch])
                this.waitForDoubleTap = false;
            }
            else {
                // Gaidām nākošo tap
                this.waitForDoubleTap = true;
                this.tapsLogExecuteTimeout = setTimeout((function(touch){
                    
                    return function() {
                        mthis.waitForDoubleTap = false;

                        mthis.fire('tap', [touch])
                    }

                })(tap.touch), this._config.doubletapWaitTimeout)


                /**
                 * @todo Te vajadzētu kaut kādu pseido little bit before tap, jo
                 * uz ios doubletapWaitTimeout ir tāds pats kā šeit iekonfigurēts
                 * bet single tap tomēr izpildās drusku ātrāk. Tas tāpēc, lai interfeiss
                 * justos atsaucīgāks. Savukārt ļoti īsu doubletapWaitTimeout nevar taisīt,
                 * jo kādam, kuram nav veikli pirksti būs grūti uztaisīt doubleTap
                 */
            }
        },

        maybeFireSingleTap: function(tap) {
            if (!tap) {
                return;
            }

            this.fire('tap', [tap.touch])
        },

        maybePreventPinch: function(ev) {
            if (this._config.disablePinch && this.touchesCount >= 2) {
                ev.preventDefault();
            }
        },

        maybeFirePinchStart: function() {
            if (this.touchesCount < 2) {
                return;
            }

            this.fire('pinchstart', [this.formatPinch(
                this.startTouches.first().x,
                this.startTouches.second().x,
                this.startTouches.first().y,
                this.startTouches.second().y
            )]);
        },

        maybeFirePinchEnd: function() {
            if (this.touchesCount < 2) {
                this.fire('pinchend', []);
            }
        },

        maybeFirePinchMove: function() {
            if (this.touchesCount < 2) {
                return;
            }

            // Pinch gadījumā interesē tikai 2 currentTouches
            this.fire('pinchmove', [{
                first: this.formatPinch(
                    this.firstMoveTouches.first().x,
                    this.firstMoveTouches.second().x,
                    this.firstMoveTouches.first().y,
                    this.firstMoveTouches.second().y
                ),
                current: this.formatPinch(
                    this.currentTouches.first().x,
                    this.currentTouches.second().x,
                    this.currentTouches.first().y,
                    this.currentTouches.second().y
                )
            }])
        },

        formatPinch: function(x1, x2, y1, y2) {
            return {
                // Pirmais touch punkts
                x1: x1,
                y1: y1,

                // Otrais touch punkts
                x2: x2,
                y2: y2,

                width: Math.abs(x1-x2),
                height: Math.abs(y1-y2),

                // Atālums starp touchiem. Hipotenūza, kur width un height ir taisnleņķa katetes
                // Aprēķinām pēc pitagora teorēmas distance = sqrt(pow(width, 2) + pow(height, 2))
                distance: Math.sqrt(Math.pow(Math.abs(x1-x2), 2) + Math.pow(Math.abs(y1-y2), 2)),

                // Pinch centrs
                center: {
                    x: this.calcMid(x1, x2),
                    y: this.calcMid(y1, y2)
                }
            }
        },

        calcMid: function(p1, p2) {
            return p1 < p2 ? (p2-p1)/2+p1 : (p1-p2)/2+p2;
        },

        formatMovement: function() {
            return {
                // Padodam konfigurācijai atbilstošu direction. Ja ir iekonfigurēts horizontal, tad padodam left or right
                direction: this.getFormattedDirection(),
                offset: this.offset,
                duration: this.duration,
                width: this.width,
                height: this.height,
                x: this.currentTouches.first().x,
                y: this.currentTouches.first().y,
                touchedElement: this.currentTouches.first().touchedElement,

                speed: this.width / this.duration,
                realDirection: this.direction
            }
        },

        getFormattedDirection: function() {
            if (this.isDirection(this._config.direction, 'horizontal') || this.isDirection(this._config.direction, 'vertical')) {
                return this.getDirection();
            }
            else if (this.isDirection(this._config.direction, 'horizontal')) {
                return this.getHorizontalDirection();
            }
            else if (this.isDirection(this._config.direction, 'vertical')) {
                return this.getHorizontalDirection();
            }
        },

        /** 
         * There we can filter if current move is valid
         * For, example, if we track only horizontal move, then ignore
         * vertical move.
         * There also can be checked, if user is scrolling page
         */
        isValidMove: function() {
            // Ja swipeLog nav pilns, tad nevaram vēl validēt move
            if (this.swipeLog.stack.length < 2) {
                return false;
            }

            /**
             * Ja ir directional swipe, tad ja ir nodetektēts direction
             * atbilstošs swipe, vairāk to nepārtraucam. Jo swipe laikā
             * var mainīties direction, no left kļūt par top
             */
            
            // Swipe direction
            if (this._config.direction.length > 0) {
                
                // Uzstādām pirmo detektēto swipe virzienu
                if (!this.moveDirection) {
                    this.moveDirection = this.getMoveDirection();
                }

                if (!this.isDirection(this._config.direction, this.moveDirection)) {
                    return false;
                }
            }

            var minMaping = {minWidth: 'width', minHeight: 'height', minDuration: 'duration'};
            var maxMaping = {maxWidth: 'width', maxHeight: 'height', maxDuration: 'duration'};

            for (var p in minMaping) {
                if (this._config[p]) {
                    if (this[minMaping[p]] < this._config[p]) {
                        return false;
                    }    
                }
                
            }

            for (var p in maxMaping) {
                if (this._config[p]) {
                    if (this[maxMaping[p]] > this._config[p]) {
                        return false;
                    }
                }
            }

            return true;
        },

        /**
         * Track swipe progress. Calculates swipe width, height and duration
         */
        trackMovment: function() {
            this.offset = {
                x: this.currentTouches.first().x - this.firstMoveTouches.first().x,
                y: this.currentTouches.first().y - this.firstMoveTouches.first().y
            };
            this.width = Math.abs(this.offset.x);
            this.height = Math.abs(this.offset.y);
            
            this.direction = this.getDirection();
        },

        trackDuration: function() {
            this.duration = this.currentTouches.first().t - this.startTouches.first().t;
        },

        trackSwipe: function() {
            // Uzkrājam pēdējās this.swipeLogStackMaxLength move kustības. No tām tiks noteikts vai ir bijis swipe
            this.swipeLog.stack.push({
                x: this.currentTouches.first().x,
                y: this.currentTouches.first().y,
                duration: this.duration
            });

            if (this.swipeLog.stack.length > this.swipeLogStackMaxLength) {
                this.swipeLog.stack.shift();
            }

            // Time between first and last logged movement
            this.swipeLog.duration = this.swipeLog.stack[this.swipeLog.stack.length-1].duration - this.swipeLog.stack[0].duration;
            this.swipeLog.width = Math.abs(this.swipeLog.stack[this.swipeLog.stack.length-1].x - this.swipeLog.stack[0].x);
            this.swipeLog.height = Math.abs(this.swipeLog.stack[this.swipeLog.stack.length-1].y - this.swipeLog.stack[0].y);
        },

        /**
         * Atgriežam virzienu vienalga kādā virzienā. Vai horizontal vai vertical.
         * Pirmo pārbaudām vertikālo virzienu. Ja tā nav, tad horizontālo
         */
        getDirection: function() {
            if (this.getVerticalDirection()) {
                return this.getVerticalDirection();
            }
            else if (this.getHorizontalDirection()) {
                return this.getHorizontalDirection();
            }
        },

        /**
         * Atgriežam tikai horizontālo virzienu: left or right
         */
        getHorizontalDirection: function() {
            if (this.currentTouches.first().x > this.startTouches.first().x) {
                return "right";
            }
            else if (this.currentTouches.first().x < this.startTouches.first().x) {
                return "left";
            }

            return false;
        },

        /**
         * Atgriežam tikai vertikālo virzienu: up or down
         */
        getVerticalDirection: function() {
            /**
             * Horizontal swipe elevation
             * When swiping left right there van be slight elveation, but this
             * does not mean user is swiping up or down
             */
            if (this.offset) {
                var e = this.offset.y / this.offset.x;

                if (e > this.slopeFactor) {
                    return "up";
                }
                else if (e < -this.slopeFactor) {
                    return "down";
                }
            }

            return false;
        },

        getMoveDirection: function() {
            if (this.isHorizontalDirection()) {
                return 'horizontal';
            }
            
            if (this.isVerticalDirection()) {
                return 'vertical';
            }

            return '';
        },

        isHorizontalDirection: function() {
            return (this.direction == "left" || this.direction == "right");
        },

        isVerticalDirection: function() {
            return (this.direction == "up" || this.direction == "down");
        },

        /**
         * Apstrādājam touch registered notikumu
         */
        handleTouchRegistered: function(touch) {
            this.touchesCount++;

            // Ja ir viens touch, tad reģistrējam kā tap
            if (this.touchesCount == 1) {
                // Reģistrējam tap
                this.registerTapLog(this.touches[touch.identifier]);
            }
        },

        handleTouchUnregistered: function(identifier) {
            this.touchesCount--;

            // Atreģistrējam tap
            this.unregisterTapLog(identifier);
        },

        /**
         * @param validateTouchedElement Reģistrējam tikai tos touch, kuri nāk no iekonfigurētā elementa
         * Tas ir vajadzīgs, lai swipe sāktos tikai uz iekofigurēto elementu
         * Pēc tam, kad notiek move, tad neskatamies uz touched elementu
         *
         * changedTouches nesatur to elementu uz kura tagad touch atrodas
         * elements vienmēr būs tas no kura sākās touch events
         * Elements, kurš pašlaik ir zem touch jānosaka ar pageX pageY vai kaut kā savādāk
         */
        registerTouches: function(ev, validateTouchedElement) {
            if (ev.changedTouches) {
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    this.registerTouch(this.formatTouch(ev.changedTouches[i]), this.eventTarget(ev.changedTouches[i]), validateTouchedElement);
                }
            }
            else {
                this.registerTouch(this.formatTouch(ev), this.eventTarget(ev), validateTouchedElement);
            }
        },

        unregisterTouches: function(ev) {
            if (ev.changedTouches) {
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    this.unregisterTouch(ev.changedTouches[i].identifier)
                }
            }
            else {
                this.unregisterTouch('_faketouch')
            }
        },

        registerTouch: function(touch, touchedElement, validateTouchedElement) {

            if (validateTouchedElement) {
                if (!this.isTheElement(touchedElement)) {
                    return false;
                }
            }
            
            // Update
            if (this.isTouchRegistered(touch)) {
                this.touches[touch.identifier] = touch;
                this.touches[touch.identifier].touchedElement = touchedElement;

                return false;
            }

            // Insert new
            this.touches[touch.identifier] = touch;
            this.touches[touch.identifier].touchedElement = touchedElement;

            // Touch ir piereģistrēts
            this.handleTouchRegistered(this.touches[touch.identifier]);
        },

        unregisterTouch: function(identifier) {

            if (typeof this.touches[identifier] != 'undefined') {
                delete this.touches[identifier];

                // Paziņojam, ka touch ir atreģistrēts
                this.handleTouchUnregistered(identifier);
            }
        },

        isTouchRegistered: function(touch) {
            return (typeof this.touches[touch.identifier] != 'undefined');
        },

        /**
         * Get touch object from event
         * We need only x, y coordinates and time of touch
         */
        // getTouch: function(ev) {
        //     var t = false;
        //     var changedTouches = ev.changedTouches;
            
        //     if (changedTouches) {
        //         t = changedTouches[0];
        //     }
        //     else {
        //         t = ev;
        //     }
            
        //     t = t ? this.formatTouch(t) : false;

        //     if (t) {
        //         // Pieglabājam elementu, uz kura notika touch
        //         t.touchedElement = this.eventTarget(ev);
        //     }

        //     return t;
        // },

        /**
         * Atgriežam touches kopiju uz doto mirkli
         */
        getTouches: function() {
            var mthis = this;
            return new List(this.map(this.touches, function(touch){
                return mthis.clone(touch);
            }))
        },

        formatTouch: function(ev) {
            return {
                identifier: (typeof ev.identifier == 'undefined' ? '_faketouch' : ev.identifier),
                x: typeof ev.pageX == 'undefined' ? ev.x : ev.pageX,
                y: typeof ev.pageY == 'undefined' ? ev.y : ev.pageY,
                t: new Date().getTime()
            }
        },

        /**
         * Reģistrējam tap logu. Piereģistrējam touch pēc tā id un piereģistrējam tā sākuma laiku
         * @param string Touch identifikators
         */
        registerTapLog: function(touch) {
            this.tapsLog[touch.identifier] = {
                touch: this.clone(touch),
                startTime: new Date().getTime(),
                endTime: undefined,
                duration: undefined,
                executed: false
            };
        },

        /**
         * Atgreģistrējam tap. Uzliekam tap end laiku pēc touch id
         * Tā lai varam pēc tam izrēķināt cik ilgs ir bijis touch
         */
        unregisterTapLog: function(identifier) {
            if (typeof this.tapsLog[identifier] != 'undefined') {
                this.registerTapEnd(this.tapsLog[identifier])
            }
        },

        clearTapLog: function() {
            this.tapsLog = {}
        },

        registerTapEnd: function(tap) {
            if (!tap.endTime) {
                tap.endTime = new Date().getTime();
                    
                // Tap ilgums
                tap.duration = tap.endTime - tap.startTime;
            }
        },

        /**
         * Atgriež pēdējo valīdo tap no tapLog
         */
        getValidTapRegistered: function() {
            var validTap = false, mthis = this;

            this.each(this.tapsLog, function(tap){
                
                if (mthis.validateTap(tap)) {
                    validTap = tap;
                }

            })

            return validTap;
        },

        validateTap: function(tap) {
            if (tap.duration > this._config.tapMinDuration && tap.duration < this._config.tapMaxDuration) {
                return true;
            }
            return false;
        },

        /**
         * Fire events attached callbacks
         */
        fire: function(eventName, args) {
            for (var i in this.events[eventName]) {
                this.events[eventName][i].apply(this, args);
            }
        },

        /**
         * Always retranslate touch move event
         * Check if swipe width or height is greater then 0
         */
        fireTouchMove: function() {
            var t = this.formatMovement();
            if (t.width > 0 || t.height > 0) {
                this.fire("touchmove", [t]);
            }
        },

        /**
         * Check if target is same as this.el or target is child of this.el
         */
        isTheElement: function(target) {
            return (target == this.el || this.isChild(target, this.el));
        },

        isChild: function(target, element) {
            var n = target.parentNode;
            while (n) {
                if (n == element) {
                    return true;
                }
                n = n.parentNode;
            }
            return false;
        },

        addEvent: function(obj, type, fn, params) {
            params = (typeof params == 'undefined' ? false : params);
            if ( obj.attachEvent ) {
                obj['e'+type+fn] = fn;
                obj[type+fn] = function(){obj['e'+type+fn](window.event)}
                obj.attachEvent('on'+type, obj[type+fn]);
            }
            else {
                obj.addEventListener(type, fn, params);
            }
        },

        removeEvent: function(obj, type, fn, params) {
            params = (typeof params == 'undefined' ? false : params);
            if ( obj.detachEvent ) {
                obj.detachEvent( 'on'+type, obj[type+fn] );
                obj[type+fn] = null;
            }
            else {
                obj.removeEventListener(type, fn, params);
            }
        },

        preventEvent: function(ev) {
            if (ev.preventDefault) {
                ev.preventDefault();
            }
            else {
                ev.returnValue = false;
            }
        },

        /**
         * Normalize event.target
         */
        eventTarget: function(ev) {
            var el;

            if (ev.target) {
                el = ev.target;
            }
            else if (ev.srcElement) {
                el = ev.srcElement
            }
            
            // Safari bug. Selected text returns text
            if (el.nodeType == 3) {
                el = el.parentNode
            }

            return el;
        },

        /**
         * Add event listener
         */
        on: function(eventName, cb) {
            if (typeof this.events[eventName] != 'undefined') {
                this.events[eventName].push(cb);
            }

            return this;
        },

        isEventsRegistered: function(eventName) {
            return (typeof this.events[eventName] != 'undefined' && this.events[eventName].length > 0);
        },

        /**
         * Set configuration parameters
         */
        config: function(config) {
            if (typeof config == 'undefined') {
                config = {};
            }

            function formatByType(value, type) {
                switch (type) {
                    case 'int': return parseInt(value, 10);
                    case 'boolean': return (value ? true : false);
                    default: return value
                }
            }
            
            function formatValue(value, config) {
                if (typeof config.multiple == 'undefined') {
                    config.multiple = false;
                }

                if (config.multiple) {
                    value = value.split(' ');
                    for (var i = 0; i < value.length; i++) {
                        value[i] = formatByType(value[i], config.type);
                    }
                }
                else {
                    value = formatByType(value, config.type)
                }

                return value;
            }

            var defConfig = {
                // Directions var būt vairāki (vertical horizontal)
                direction:  {value: ['horizontal', 'vertical'], type: 'string', multiple: true},

                minWidth: {value: false, type: 'int'},
                minHeight: {value: false, type: 'int'},
                minDuration: {value: false, type: 'int'},

                maxWidth: {value: false, type: 'int'},
                maxHeight: {value: false, type: 'int'},
                maxDuration: {value: false, type: 'int'},

                disablePinch: {value: false, type: 'boolean'},

                /**
                 * Prevent any movement. Šis notiek touchstart eventā
                 * Šis palīdz iOS gadījumā, kad neskatoties uz prevent move
                 * lapa tā pat dabū skrolēties ar elastic
                 */
                alwaysPreventTouchStart: {value: false, type: 'boolean'},

                doubletapWaitTimeout: {value: 530, type: 'int'},
                tapMaxDuration: {value: 600, type: 'int'},
                tapMinDuration: {value: 5, type: 'int'}
            }

            // Init empty config
            this._config = {};

            // Append defaults
            for (var p in defConfig) {
                this._config[p] = typeof config[p] == 'undefined' ? defConfig[p].value : formatValue(config[p], defConfig[p]);
            }
        },

        setTouchAction: function(direction) {
            var c = [];

            if (this.isDirection(direction, 'vertical')) {
                c.push('pan-x');
            }

            if (this.isDirection(direction, 'horizontal')) {
                c.push('pan-y');
            }
            
            // Pievienojam touch-action
            if (c.length > 0) {
                this.el.style.touchAction = c.join(' ');    
            }
            else {
                this.el.style.touchAction = 'none';
            }
        },

        isDirection: function(directionsArray, direction) {
            for (var i = 0; i < directionsArray.length; i++) {
                if (directionsArray[i] == direction) {
                    return true
                }
            }
            return false;
        },

        /**
         * Detect if main (left) button is pressed
         */
        isMainMouseButton: function(ev) {
            if (typeof ev['which'] != 'undefined') {
                return ev.which == 1; 
            }
            else if (typeof ec['button'] != 'undefined') {
                return ev.button == 0;
            }
            else {
                return true;
            }
        },

        /**
         * Destroy swipe monitoring
         */
        destroy: function() {
            // Remove all event listeners
            this.handleEvents('remove');
            this.events = [];
        },

        objProps: function(obj) {
            var r = [];
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) {
                    r.push(name);
                }
            }
            return r;
        },

        map: function(obj, cb) {
            var r = [];
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) {
                    r.push(cb(obj[name], obj));
                }
            }
            return r;
        },

        each: function(obj, cb) {
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) {
                    cb(obj[name], name);
                }
            }
        },

        clone: function(obj) {
            var r = {};
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) {
                    r[name] = obj[name];
                }
            }
            return r;
        }
    }

    return Swipe;
});
},{}],36:[function(require,module,exports){
var getElementOuterDimensions = require('./getElementOuterDimensions');

function gv(obj, name, dv) {
    return typeof obj[name] == 'undefined' ? dv : obj[name]
}

function slide(el, index, xs) {
    // X pozīcijas
    if (typeof xs == 'undefined') {
        xs = {}
    }

    this.el = el;
    this.width = this.getWidth();
    /**
     * Šis ir reālais slide indekss. Ir ierobežots skaits ar slaidiem
     */
    this.indexReal = index;
    /**
     * Šis ir indekss, kad notiek bezgalīgā swaipošana. Slaidi tiek pārlikti viens aiz otra
     * Līdz ar to indekss bezgalīgi palielinās. Jo tas slaids, kas bija pats pirmais vienā
     * mirklī tiek pārvietos uz pašām beigām un šajā mirklī mainās slaida indekss
     */
    this.index = index;

    this.pageReal = 0;
    this.page = 0;

    // Reālā x pozīcija parent elementā
    this.xReal = gv(xs, 'xReal', 0);

    // Uzstādītā x nobīde. Tad, kad vajag pārvietot citā vietā
    this.x = gv(xs, 'x', 0);

    // Handle move offseti
    this.xOffset = gv(xs, 'xOffset', 0);
}

slide.prototype = {
    getWidth: function() {
        return getElementOuterDimensions(this.el, true).width;
    },
    updateWidth: function() {
        this.width = this.getWidth();
    },
    /**
     * Pozicionējam elementu
     * x pozīcija veidojas no tekošās x nobīdes + uzstādītā X nobīde
     */
    updateCss: function() {
        this.el.style.transform = 'translate3d('+(this.x + this.xOffset)+'px,0,0)'
    },
    setXOffset: function(v) {
        this.xOffset = v
    },
    /**
     * Atgriežam reālo X pozīciju. Ņemot vērā fizisko novietoju
     * un ņemot vērā offset nobīdījumu
     */
    getX: function() {
        return this.xReal + this.x + this.xOffset;
    },
    /**
     * Tas pats, kas getX, tikai bez move offset
     * Tā ir x pozīcija pirms notika slide move darbība
     * Kamēr notiek move kūstība tiek mainīts offsetX un tas
     * tiek pielikts pie slide x pozīcijas.
     * Šis x ir tāds, ja kustība nebūtu bijusi
     */
    getXWithoutOffset: function() {
        return this.xReal + this.x;
    },
    start: function() {
        // Nofiksējam rēalo x nobīdi
        this.x = this.x + this.xOffset;

        // Temp x offsetu nonullējam
        this.xOffset = 0;
    }
}

module.exports = slide
},{"./getElementOuterDimensions":31}],37:[function(require,module,exports){
var getElementOuterDimensions = require('./getElementOuterDimensions');
var elementsCollection = require('./elementsCollection');
var slide = require('./slide');

var Slides = function(slides, viewportWidth, conf) {
    this.viewport = {}

    // Nākošā slide X pozīcija
    this.slidesCount = 0;

    this.slides = [];

    this.conf = conf;

    this.pagesCountCallback = conf.onPagesCount;

    this.slideAddCallbacks = [];
    if (this.conf && this.conf.onSlideAdd) {
        this.slideAddCallbacks.push(this.conf.onSlideAdd)
    }

    this.slidesElements = new elementsCollection(slides);

    this.setViewportWidth(viewportWidth);
    this.prepareSlides(this.slidesElements);
}

Slides.prototype = {

    prepareSlides: function(slides) {
        var mthis = this;

        /**
         * Ja ir absolūti pozicionēti elementi, visi viens virs
         * otra, tad šeit nopozicionējam vienu aiz otra
         */
        if (this.conf.positionItems) {
            this.positionItems();
        }
        

        slides.each(function(slide){
            
            mthis.push(slide)
        })

        this.addPageNumbers();

        this.balanceSlides();

        this.pagesCountCallback(this.getMaxPage());
    },

    /**
     * @todo šito vajag uztaisīt
     * Izkārtojam absolūti pozicionētos elementis vienu aiz otra
     */
    positionItems: function() {
        var mthis = this;
        var x = 0;
        this.slidesElements.each(function(el){
            el.style.left = x+'px';

            x = x + getElementOuterDimensions(el).width + mthis.getSlidesPadding();
        })
    },

    reset: function() {
        this.slides = [];
        this.prepareSlides(this.slidesElements);
    },

    setViewportWidth: function(width) {
        this.viewport.width = width;
    },

    resize: function() {

        /**
         *
         * @todo Varbūt vajag kaut kā inteliģentāk pārrēķināt
         * Jāņem vērā tekošais slides index
         * jo lietotājs var būt aizskrolējis ļoti tālu
         *
         */
        this.reset();

    },

    /**
     * Rādām slide ar padoto index
     * tākā šis ir infinity slide, tad attiecīgi index var būt jebkāds
     * padotais index tiek pārrēķināts uz reālo slide index. Jo slides
     * skaits ir ierobežots un tie tiek reused
     *
     * Fiziski pārvietojam padoto index uz sākumu. 
     * Visus pārējs slides pakārtojam padotajam slide index
     */
    showByIndex: function(index) {
        // Sagatvojas slide priekš pārvietošanas
        this.start();

        // Pēc padotā index atrodam reālo slide index
        var realIndex = index % this.slidesCount;

        /**
         * Tagad meklējam slide, kuram atbilst realIndex un 
         * pieglabājam slide indeksu masīvā
         */
        var fi;
        for (var i = 0; i < this.slidesCount; i++) {
            if (this.slides[i].indexReal == realIndex) {
                fi = i;
                break;
            }
        }

        /**
         * Norādīto slide liekam kā pašu pirmo vizuāli.
         * Visus slides, kas ir aiz tā izkārtojam secīgi
         */
        var xOffset = 0;
        for (var i = 0; i < this.slidesCount; i++) {
            this.slides[fi].x = (-this.slides[fi].xReal) + xOffset;
            this.slides[fi].index = index;

            // Palielinām par slide platumu + padding
            xOffset += this.slides[fi].width + this.getSlidesPadding();

            // Atjaunojam css un izpildām callabacks
            this.slides[fi].updateCss();
            this.executeSlideAddCallbacks(this.slides[fi].index, this.slides[fi].el);

            // Visiem slaidiem pielabojam indekss secīgi
            index++;

            /**
             * Pārejam pie nākošā slide. Kad sasniegtas masīva beigas, tad 
             * metam ripā un sākam no masīva sākuma
             */
            fi++;
            if (fi == this.slidesCount) {
                fi = 0;
            }
        }

        this.balanceSlides();
    },

    /**
     * Atgriežam slide pēc kārtas numura redzamājā daļā
     */
    getByIndex: function(index) {
        for (var i = 0; i < this.slidesCount; i++) {
            if (this.slides[i].index === index) {
                return this.slides[i];
            }
        }

        return false;
    },

    /**
     * Pieeja pirmajam slide
     */
    first: function() {
        return this.slides[0];
    },

    /**
     * Pieeja pēdējam slide
     */
    last: function() {
        if (this.slidesCount > 0) {
            return this.slides[this.slidesCount-1];
        }

        return false;
    },

    /**
     * Atgriežam slide, kurš vizuāli ir pats pēdējais
     * Vizuāli pret viewport
     */
    visualLast: function() {
        var r = 0;
        for (var i = 0; i < this.slidesCount; i++) {
            if (this.slides[r].getX() < this.slides[i].getX()) {
                r = i;
            }
        }
        return this.slides[r];
    },

    /**
     * Atgriežam slide, kurš vizuāli ir pats pirmais
     */
    visualFirst: function() {
        var r;
        for (var i = 0; i < this.slidesCount; i++) {
            if (typeof r == 'undefined' || this.slides[r].getX() > this.slides[i].getX()) {
                r = i;
            }
        }
        return this.slides[r];
    },    

    nextIndex: function() {
        if (this.last()) {
            return this.last().index + 1;
        }

        return 0;
    },

    nextXReal: function() {
        if (this.last()) {
            return this.last().xReal + this.last().width + this.getSlidesPadding();
        }

        return 0;
    },

    /**
     * Saskaitām cik elementu ir ārpus viewport no labās puses
     */ 
    slidesCountAfterViewport: function() {
        var r = 0;
        for (var i = 0; i < this.slidesCount; i++) {
            if (this.slides[i].getX() > this.viewport.width) {
                r++;
            }
        }

        return r;
    },

    /**
     * Saskaitām cik elementu ir ārpus viewport no labās puses
     */ 
    slidesCountBeforeViewport: function() {
        var r = 0;
        for (var i = 0; i < this.slidesCount; i++) {
            if (this.slides[i].getX() + this.slides[i].width < 0) {
                r++;
            }
        }

        return r;
    },

    /**
     * Pievienojam elementu masīva beigās
     */
    push: function(el) {
        this.pushWithIndex(el, this.nextIndex());
    },

    pushWithIndex: function(el, index) {
        var s = new slide(el, index, {
            // Saglabājam reālo x pozīciju
            xReal: this.nextXReal()
        })
        
        this.slidesCount = this.slides.push(s);

        s.updateCss();

        this.executeSlideAddCallbacks(this.last().index, this.last().el);
    },

    /**
     * Uzsākot kustību pieglabājam katra slide startX
     */
    start: function() {
        this.slides.map(function(s){
            s.start();
        }) 
    },
    
    /**
     * Katram slide ir savs x
     * Uzliekam x offset, bet pašu x nemainām
     */
    setXOffset: function(offset) {

        for (var i = 0; i < this.slidesCount; i++) {
            this.slides[i].setXOffset(offset);
            this.slides[i].updateCss();
        }


        this.balanceSlides();
    },

    /**
     * Pārvietojam pēdējo slaidu rindā uz rindas sākumu
     */
    moveLastToFirst: function() {
        var slide = this.visualLast();

        var firstSlide = this.visualFirst();

        var w = slide.width + this.getSlidesPadding();

        // Samazinām index. Reālo indekss neaiztiekam
        slide.index = firstSlide.index - 1;

        slide.x = (firstSlide.xReal - (slide.xReal + w)) + firstSlide.x

        slide.updateCss();

        this.executeSlideAddCallbacks(slide.index, slide.el);
    },

    /**
     * Vizuāli pārvietojam pirmo slaid uz beigām
     */
    moveFirstToLast: function() {
        var slide = this.visualFirst();

        var lastSlide = this.visualLast();

        var w = lastSlide.width + this.getSlidesPadding();
        
        // Palielinām index. Reālo indekss neaiztiekam
        slide.index = lastSlide.index + 1;
        
        slide.x = ((lastSlide.xReal + w) - slide.xReal) + lastSlide.x;

        slide.updateCss();

        this.executeSlideAddCallbacks(slide.index, slide.el);
    },

    balanceSlides: function() {

        if (!this.conf.rotateItems) {
            return;
        }

        // Balansējam tikai, ja viewport.width > 0
        if (this.viewport.width <= 0) {
            return;
        }

        var b = this.slidesCountBeforeViewport();
        var a = this.slidesCountAfterViewport();

        /**
         * Aprēķinām starpību starp items pirms un pēc. Dala ar divi
         * Apaļojam uz leju
         * Atkarībā no tā vai d > 0 vai d < 0 noteiksim virzienu, kurā pārvietot slaidus
         */
        var d = Math.floor((a - b) / 2);


        // Ja nav neviena slaida, ko pārvietot, tad bail
        if (Math.abs(d) < 1) {
            return;
        }

        /**
         * Ja d < 0, tad pārvietojam no beigām uz sākumu
         * Ja d > 0, tad pārvietojam no sākuma uz beigām
         */
        var method = d < 0 ? 'moveFirstToLast' : 'moveLastToFirst';

        d = Math.abs(d);
        for (var i = 0; i < d; i++) {
            this[method]();
        }
    },

    executeSlideAddCallbacks: function() {
        for (var i = 0; i < this.slideAddCallbacks.length; i++) {
            this.slideAddCallbacks[i].apply(this, arguments);
        }
    },

    getSlidesPadding: function() {
        return this.conf.slidesPadding();
    },

    /**
     * Sakārtojam slaides pēc vizuālā izkārtojuma
     */
    getSortedVisual: function(direction) {
        var r = [];
        for (var i = 0; i < this.slidesCount; i++) {
            r.push(this.slides[i]);
        }

        return r.sort(function(a, b){
            if (a.getX() < b.getX()) {
                return direction == 'asc' ? -1 : 1;
            }
            else if (a.getX() > b.getX()) {
                return 0;
            }
            else if (a.getX() > b.getX()) {
                return direction == 'asc' ? 1 : -1;
            }
        })
    },

    isBetweenX: function(slide, x1, x2) {
        if (slide.getX() > x1 && slide.getX() < x2) {
            return true;
        }
    },

    /**
     * Meklējam pirmo slide starp padotajām x koordinātēm
     * @searchDirection meklēšanas virziens ASC vai DESC
     */
    findBetweenX: function(x1, x2, searchDirection) {

        // Meklējam pēc sakārtotiem pēc vizuālā izkārtojuma
        var r = this.getSortedVisual(searchDirection);

        for (var i = 0; i < r.length; i++) {
            if (this.isBetweenX(r[i], x1, x2)) {
                // Atgriežam slide instanci no īstā slides masīva
                return this.slides[r[i].indexReal];
            }
        }
        
        return undefined;
    },

    /**
     * Atrodam slide, kura getX ir viss tuvāk x no kreisās puses
     */
    findClosestToXFromLeft: function(x) {
        var r;
        for (var i = 0; i < this.slidesCount; i++) {
            // Izlaižam visus, kas ir lielāki par x
            if (this.slides[i].getX() > x) {
                continue;
            }
            if (typeof r == 'undefined' || this.slides[r].getX() < this.slides[i].getX()) {
                r = i;
            }
        }
        return this.slides[r];
    },

    /**
     * Atrodam nākošo offsetX aiz norādītā x
     */
    findClosestToXFromRight: function(x) {
        var r;
        for (var i = 0; i < this.slidesCount; i++) {
            // Izlaišam visus, kas ir lielāki par x
            if (this.slides[i].getX() < x) {
                continue;
            }
            if (typeof r == 'undefined' || this.slides[r].getX() > this.slides[i].getX()) {
                r = i;
            }
        }
        return this.slides[r];
    },

    findFirstBetweenX: function(x1, x2) {
        return this.findBetweenX(x1, x2, 'asc');
    },

    findLastBetweenX: function(x1, x2) {
        return this.findBetweenX(x1, x2, 'desc');  
    },

    /**
     * Pievienojam katram slaid lapas numuru, kurā tas iekrīt
     */
    addPageNumbers: function() {
        var page = 1, t = 0;

        for (var i = 0; i < this.slidesCount; i++) {

            this.slides[i].pageReal = page;
            this.slides[i].page = page;
        
            t += (this.slides[i].width + this.getSlidesPadding());

            // Nedaudz smaziām viewport platumu, lai lapā netiktu ieskaitīts
            // slide, kuram tikai daži pikseļi ir lapā
            if (t >= this.viewport.width - 4) {
                page++;
                t = 0;
            }
        }
    },

    /**
     * Saskaitām cik lapās var sadalīt visus slaidus
     * Lapa ir tad, kad to piepilda vairāki slaidi
     * Lapā var būt 1 vai vairāki slaidi
     */
    getMaxPage: function() {
        var r = 1;

        for (var i = 0; i < this.slidesCount; i++) {
            if (this.slides[i].pageReal > r) {
                r = this.slides[i].pageReal;
            }
        }

        return r;
    }
}

module.exports = Slides;
},{"./elementsCollection":29,"./getElementOuterDimensions":31,"./slide":36}]},{},[3])(3)
});
